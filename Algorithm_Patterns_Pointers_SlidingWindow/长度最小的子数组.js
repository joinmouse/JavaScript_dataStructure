/**
 * ============================================
 * 变长滑动窗口：长度最小的子数组
 * ============================================
 * 
 * 问题描述：
 * 给定一个含有 n 个正整数的数组和一个正整数 target。
 * 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr]，
 * 并返回其长度。如果不存在符合条件的子数组，返回 0。
 * 
 * 
 * 输入：
 * - target: 正整数，目标和
 * - nums: 正整数数组
 * 
 * 输出：
 * - 数字：满足条件的子数组的长度，如果不存在则返回 0
 * 
 * 
 * 示例：
 * 
 * 示例 1：
 * 输入：target = 7, nums = [2,3,1,2,4,3]
 * 输出：2
 * 解释：子数组 [4,3] 是满足条件的最小长度子数组。
 * 
 * 示例 2：
 * 输入：target = 4, nums = [1,4,4]
 * 输出：1
 * 解释：子数组 [4] 是满足条件的最小长度子数组。
 * 
 * 示例 3：
 * 输入：target = 11, nums = [1,2,3,4,5]
 * 输出：3
 * 解释：子数组 [3,4,5] 是满足条件的最小长度子数组。
 * 
 * 
 * 算法思路：变长滑动窗口
 * 
 * 1. 使用左右两个指针维护一个窗口 [left, right]
 * 2. 右指针扩展窗口，累加窗口和
 * 3. 当窗口和 ≥ target 时，尝试收缩窗口（移动左指针）
 *    - 在收缩过程中，记录满足条件的最小窗口长度
 * 4. 继续扩展右指针，直到遍历完整个数组
 * 
 * 
 * 复杂度分析：
 * - 时间复杂度：O(n)，每个元素最多被访问两次（一次被右指针添加，一次被左指针移除）
 * - 空间复杂度：O(1)，只使用了常数级别的额外空间
 * 
 * 
 * 关键点：
 * - 窗口长度不固定，而是根据条件动态调整
 * - 每次满足条件后，尝试收缩窗口以找到更小的解
 * - 初始结果可以设置为 Infinity（无穷大）或数组长度 + 1
 * 
 */


export function minSubArrayLen(target, nums) {
  let left = 0; // 滑动窗口左指针

  let windowSum = 0; // 当前窗口和
  let minLength = Infinity; // 最小子数组长度初始化为无穷大

  for (let right = 0; right < nums.length; right++) {
    windowSum += nums[right]; // 扩展窗口，增加右侧元素

    // 只要达标就需要收缩窗口
    while(windowSum >= target) {
      minLength = Math.min(minLength, right - left + 1);

      windowSum -= nums[left]; // 收缩窗口，减少左侧元素
      left++;
    }
  }
  
  return minLength == Infinity ? 0 : minLength;
}
